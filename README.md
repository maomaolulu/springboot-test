1. Spring Boot 概述1.1. Spring Boot 是什么Spring Boot 是一套基于 Spring 框架的微框架。1.2. Spring Boot 框架出现的背景由于 Spring 是一个轻量级的企业开发框架， 主要的功能就是用于整合和管理其他框架。随着整合的框架越来越多， Spring 的整合配置也日益繁琐。 在这个情况下， Spring 团体有了一个想法： 就是将平时主流使用的到的框架的整合配置预先写好， 然后通过简单的几个参数就可以实现框架的快速整合。这个想法催生 Spring boot 框架。我们将这个实现了各种主流框架与 Spring 的自动整合的框架 Spring boot 称为 Spring 微框架：1.3. Spring Boot 的作用是什么就是大大减少了 Spring 与其他框架整合的代码， 也实现了 Spring 开发的 Web 应用的快速部署；简化Spring应用开发的一个框架；整个Spring技术栈的一个大整合；J2EE开发的一站式解决方案；1.4. Spring Boot 的特点1.实现了各种主流的框架的快速整合2.实现了 Spring 的应用的快速部署， 使用 Spring Boot 的 Web 应用可以以 Jar 的方式部署。1.5. Spring Boot 学习的前提1.由于 Spring Boot 的最小配置都是基于 SpringMVC 框架的， 所以学习 Spring Boot 先要有 Spring和 SpringMVC 框架的基础。2.SpringBoot 默认不支持 JSP 视图， 官方推荐使用 Thymeleaf 或者 Freemarker 模板引擎。 本文档没有对这两个模板引擎作详细介绍。Spring Boot 中可以使用 Spring 框架的所有注解。 如果没有学过纯注解 Spring 框架配置， 需要先学习 Spring 纯注解的配置。所谓的纯注解： 就是一个 Spring 配置文件都没有的配置。涉及 Spring 框架的纯注解配置类常用注解如下：注解名说明@Configuration声明一个配置类， 配置类的功能等同 spring 的配置文件（重点）@Bean将没有声明@Component/@Controller/@Serivce/@Repository 的类加入到 Spring 容器等同于 Spring 配置文件的<bean>标签@PropertySource在 Spring 的配置里读取， 增加的这个注解， 可以使用@Value 注解获得 properties 文件的内容@Value获得上下文中， Properties 文件的内容等同与 Spring 配置文件的${key}@ComponentScan用于扫描类， 创建对象到 Spring 容器中等同 Spring 配置文件<context:component-scan>@ConditionalOnMissingBean表示如果 Spring 容器已经有该类的对象就不执行创建对象的方法再创建一次了。1.6. Spring Boot 准备工具学习 Spring Boot 建议使用 Eclipse 安装 STS 插件或者直接使用 STS 开发工具。下载官网： https://spring.io/tools/sts1.7. 参考资料本文档编写参考了1.Spring 官方的示例代码， 地址如下：https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples2.SpringBoot 官方参考文档， 地址如下：https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started3.spring boot 自动配置的框架， 路径如下：https://github.com/spring-projects/spring-boot/tree/master/spring-boot-starters2. Spring Boot 的入门2.1. 简单配置入门2.1.1. 配置流程1.新建一个 maven 项目2.填写创建项目的信息， 注意使用 jar 的方式创建项目就可以3.到 spring boot 官方复制 pom 的依赖到 pom.xml 文件网站地址为:http://projects.spring.io/spring-boot/pom.xml 文件内容如下：<?xml version="1.0" encoding="UTF-8"?><project xmlns="http://maven.apache.org/POM/4.0.0"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><modelVersion>4.0.0</modelVersion><groupId>com.ngari</groupId><artifactId>springboot-test</artifactId><version>1.0-SNAPSHOT</version><parent><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-parent</artifactId><version>1.5.4.RELEASE</version></parent><dependencies><dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-web</artifactId></dependency></dependencies></project>4.编写一个简单的 Java 类package com.ngari.controller;import org.springframework.beans.factory.annotation.Configurable;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/*** @ClassName SampleController* @Description* @Author maoLy* @Date 2020/12/7**/@Controller@EnableAutoConfigurationpublic class SampleController {/**10* 表示如果访问路径/,返回字符串 Hello World!*/@RequestMapping("/")@ResponseBodypublic String home() {return "Hello World!";}public static void main(String[] args) throws Exception {//启动 Spring Boot 程序SpringApplication.run(SampleController.class, args);}}5.启动 Spring Boot 程序6.启动成功， 控制台提示我们使用 8080 端口访问7.使用浏览器访问 8080 端口2.1.2. 注意事项maven 是需要联网下载的 jar 包的。 注意一下网络是否畅通。2.2. 使用@SpringBootApplication 注解配置上面的示例有一个问题， 代码如下：SpringApplication.run(SampleController.class, args);启动的 Controller 只有一个， 如果一个项目需要将多个类扫描到 Spring 的容器中如何解决呢？答： 使用@SpringBootApplication 注解来配置。入口类使用@SpringBootApplication 注解， 启动项目时， SpringBoot 框架会扫描入口类的同级目录和子目录的类的对象到 Spring 容器。2.2.1. 配置流程1.创建一个 Maven 项目2.将 Spring boot 的依赖复制到 pom.xml 文件<?xml version="1.0" encoding="UTF-8"?><project xmlns="http://maven.apache.org/POM/4.0.0"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><modelVersion>4.0.0</modelVersion><groupId>com.ngari</groupId><artifactId>springboot-test</artifactId><version>1.0-SNAPSHOT</version><parent><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-parent</artifactId><version>1.5.4.RELEASE</version></parent><dependencies><dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-web</artifactId></dependency></dependencies></project>3.将项目简单分层4.在com.ngari创建一个入口类 Application.javapackage com.ngari;import com.ngari.controller.SampleController;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/*** @ClassName Application* @Description springboot入口启动类* @Author maoLy* @Date 2020/12/7**/@SpringBootApplicationpublic class Application {public static void main(String[] args) throws Exception {//启动 Spring Boot 程序SpringApplication.run(SampleController.class, args);}5.创建一个 Controller,业务控制器package com.ngari.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/*** @ClassName HelloController* @Description* @Author maoLy* @Date 2020/12/7**/@Controllerpublic class HelloController {@RequestMapping("/")@ResponseBodypublic String say() {return "Hello World!";}} 6.启动项目， 控制台返回访问端口7.使用浏览器访问2.2.2. 注意事项1.为什么放在 com.ngari 包下呢？答:@SpringBootApplication 的配置默认根据入口类的所在位置扫描包以及入口类所在位置以及子包范围。根据以上配置， 使用@SpringBootApplication 配置 Spring boot 项目。 会自动扫描 cn.itheima.*下面HelloController 类。从而可以得出使用@SpringBootApplication 可以实现将多个类扫描到 Spring 容器里面。3. SpringBoot 常见基础包说明1.spring-boot-starter-web-1.5.4.RELEASE.jar： 仅仅存放 web 项目需要的 jar 包的 pom.xml2.spring-boot-starter-1.5.4.RELEASE.jar:仅仅存放 springboot 最小核心需要的 jar 包的 pom.xml3.spring-boot-starter-logging-1.5.4.RELEASE.jar:仅仅存放日志输出需要的 jar 包的 pom.xml4.spring-boot-1.5.4.RELEASE.jar:springboot 框架核心包spring-boot-autoconfigure-1.5.4.RELEASE.jar： 默认支持的自动配置的框架的配置包（重点）重点是 spring-boot-autoconfigure 包,因为 spring boot 的所有内置的自动配置的类都在里面！4. 常用 API 说明4.1. SpringApplication 类4.1.1. 说明作用:用于启动 Spring Boot 的程序， 根据传入的类声明的注解来决定不同的启动方式。4.1.2. 示例代码package com.ngari;import com.ngari.controller.SampleController;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/*** @ClassName Application* @Description springboot入口启动类* @Author maoLy* @Date 2020/12/7**/@SpringBootApplicationpublic class Application {public static void main(String[] args) throws Exception {//启动 Spring Boot 程序SpringApplication.run(SampleController.class, args);}}4.2. @EnableAutoConfiguration 注解4.2.1. 注解的声明package org.springframework.boot.autoconfigure;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.context.annotation.Import;@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import({EnableAutoConfigurationImportSelector.class})public @interface EnableAutoConfiguration {String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";Class<?>[] exclude() default {};String[] excludeName() default {};}4.2.2. 作用@EnableAutoConfiguration 注解的作用是： 启动程序时， 告诉 SpringApplication 启动对象使用SpringBoot 的默认配置。只要在 SpringBoot 项目的入口类配置了@EnableAutoConfiguration， 在 SpringBoot 框架启动是就会 自 动 根 据 你 导 入 的 jar 包 来 加 载 spring-boot-autoconfigure-1.5.4.RELEASE-sources.jar 中 的xxxAutoconfiguration 配置类， 使用其默认配置。4.2.3. 属性说明exclude 属性： 使用 Class 格式的方式， 排除默认自动启动中不需要的配置类excludeName 属性： 使用类的限制名的方式， 排除默认自动启动中不需要的配置类4.3. @SpringBootApplication 注解4.3.1. 注解声明package org.springframework.boot.autoconfigure;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.boot.SpringBootConfiguration;import org.springframework.boot.context.TypeExcludeFilter;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.FilterType;import org.springframework.context.annotation.ComponentScan.Filter;import org.springframework.core.annotation.AliasFor;@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = {@Filter(type = FilterType.CUSTOM,classes = {TypeExcludeFilter.class}), @Filter(type = FilterType.CUSTOM,classes = {AutoConfigurationExcludeFilter.class})})public @interface SpringBootApplication {@AliasFor(annotation = EnableAutoConfiguration.class,attribute = "exclude")Class<?>[] exclude() default {};@AliasFor(annotation = EnableAutoConfiguration.class,attribute = "excludeName")String[] excludeName() default {};@AliasFor(annotation = ComponentScan.class,attribute = "basePackages")String[] scanBasePackages() default {};@AliasFor(annotation = ComponentScan.class,attribute = "basePackageClasses")Class<?>[] scanBasePackageClasses() default {};}根据注解的声明可以得出： @SpringBootApplication 注解也是启动 Springboot 的默认配置。 只是在@EnableAutoConfiguration 注解的基础上增加了扫描包@ComponentScan 的这个注解。 实现了并且扫描指定范围的类创建对象到容器里面。4.3.2. 属性说明1.basePackages 属性@SpringBootApplication 默认扫描的范围是使用该注解的当前的类的包以及子包,如果要指定其他范围的包， 可以是 basePackages 指定。2.basePackageClasses 属性用于精确指定哪些类需要创建对象加载到 Spring 容器里面。3.exclude 属性通过 Class 的方式排除不扫描的类， 就是该类不创建对象。4.excludeName 属性通过类的全限制名的方式， 排除不扫描的类,指定的类不会在容器中创建对象。4.4. @AutoConfigureBefore 注解4.4.1. 注解说明指定在 SpringBoot 框架自动配置的配置类执行完成之前， 执行指定的自定义的配置类。如果放在 Application 入口类， 表示在所有自动配置的配置类还没有可以就先加载自定义的配置类。@AutoConfigureBefore 注解属性：value:使用类的方式指定自动配置类name： 使用类的全限制名（字符串） 类指定配置类4.4.2. 示例代码1.创建一个普通的类， 没有任何注解package com.ngari.utils;/*** @ClassName TestUtils* @Description* @Author maoLy* @Date 2020/12/7**/public class TestUtils {/*** 返回测试信息* @return*/public String test(){return "-测试注入对象成功-";}}2.创建一个自定义配置类， 注入普通的类到 Spring 容器package com.ngari.config;import com.ngari.utils.TestUtils;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/*** @ClassName MyConfiguration* @Description* @Author maoLy* @Date 2020/12/7**/@Configurationpublic class MyConfiguration {/*** 返回一个对象到容器* @return*/@Bean(name="testUtils")//表示如果 Spring 容器有 TestUtils 的对象就不执行这个方法在创建一次了。@ConditionalOnMissingBean(TestUtils.class)public TestUtils getTestUtils(){TestUtils testUtils=new TestUtils();return testUtils;}}3.在入口类配置加入自定义配置类package com.ngari;import com.ngari.config.MyConfiguration;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.AutoConfigureBefore;import org.springframework.boot.autoconfigure.SpringBootApplication;/*** @ClassName Application* @Description springboot入口启动类* @Author maoLy* @Date 2020/12/7**/@SpringBootApplication//在自动配置的配置类之前启动自定义的配置类@AutoConfigureBefore(value= MyConfiguration.class)public class Application {public static void main(String[] args) throws Exception {//启动 Spring Boot 程序SpringApplication.run(Application.class, args);}}4.在 Controller 里面使用这个注入的对象package com.ngari.controller;import com.ngari.utils.TestUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/*** @ClassName TestUtilsController* @Description* @Author maoLy* @Date 2020/12/7**/@Controllerpublic class TestUtilsController {@Autowiredprivate TestUtils testUtils;@RequestMapping("/test")@ResponseBodypublic String testConfig(){return testUtils.test();}}5.测试， 成功4.5. @AutoConfigureAfter 注解指定在 SpringBoot 框架自动配置的配置类执行完成之后， 然后执行指定的自定义的配置类。4.6. @AutoConfigureOrder 注解用于指定自动配置加载配置类的顺序。4.7. @SpringBootTest 注解4.7.1. 注解说明用于使用 JUnit 测试 SpringBoot 程序， 启动 SpringBoot 框架。 测试 SpringBoot 一定要加上。4.7.2. 示例代码package cn.itheima.test;import java.sql.SQLException;import javax.sql.DataSource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)//如果不加该注解， 无法启动 SpringBoot@SpringBootTestpublic class DataSourceTest {@Autowiredprivate DataSource dataSource;@Testpublic void dataSource() {try {23System.out.println(dataSource.getConnection());} catch (SQLException e) {// TODO Auto-generated catch blocke.printStackTrace();}}} 5. SpringBoot 配置流程（重点）5.1. 概述Spring Boot 框架是一个将整合框架的整合代码都写好了的框架。所以我们要知道它的工作原理才能够， 找到各种整合框架可以配置的属性， 以及属性对应的属性名。本章主要讲述如何在 SpringBoot 框架代码中找到 application.properties 配置文件的属性值。5.2. 配置流程说明1.SpringBoot 的 spring-boot-autoconfigure-1.5.4.RELEASE.jar 中编写了所有内置支持的框架的自动整合代码2.所有支持的框架根据功能类型来划分包， 每个包都有一个 XxxxAutoConfiguration 配置类， 都是一个基于纯注解的配置类， 是各种框架整合的框架代码。 如图所示：3.如果配置的框架有默认的配置参数， 都放在一个命名为 XxxxProperties 的属性， 如图所示4.通过项目的 resources 下的 application.properties 文件可以修改每个整合框架的默认属性， 从而实现了快速整合的目的。5.3. 配置流程图第一步： 配置一个内置整合框架的参数， 先到 spring-boot-autoconfigure-1.5.4.RELEASE.jar 找到对应的模块。第二步： 如果该框架有可以配置的参数， 那么对应的整合模块中一定有一个 XxxxProperties 类，在里面可以找可以设置的参数。第三部： 在 resources 源目录下的 application.properties 文件里面可以修改 XxxxProperties 类中默认的参数。配置流程如下：6. 配置文件Spring Boot 的参数配置文件支持两种格式。 分别为 application.propertie， application.yml。配置 Spring Boot 时可以二选一。application.propertie： 是键值对风格application.yml： 是层级键值对风格6.1. application.propertie 配置文件6.1.1. application.propertie 说明默认情况下， Spring Boot 会加载 resources 目录下的 application.properties 来获得配置的参数。6.1.2. application.propertie 多配置文件支持1.在 application.properties 配置文件下， 增加多个 application-xxx.properties 文件名的配置文件，其中 xxx 是一个任意的字符串。例如：application-database.propertiesapplication-mvc.propertiesapplication-freemarker.properties2.在 application.properties 总配置文件指定， 加载的多个配置文件例如： 要同时使用， 四个配置文件application.properties、application-database.propertiesapplication-mvc.propertiesapplication-freemarker.properties那么在 application.properties 其他配置文件指定为：spring.profiles.active=database,mvc,freemarker6.2. application.yml 配置文件6.2.1. application.yml 说明SpringBoot 支持一种由 SpringBoot 框架自制的配置文件格式。 后缀为 yml。 yml 后缀的配置文件的功能和 properties 后缀的配置文件的功能是一致的。 配置时可以二选一。例如： 配置文件： application.properties#配置数据源spring.datasource.url=jdbc:mysql://localhost:3306/schoolspring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.username=rootspring.datasource.password=123456spring.datasource.type=org.apache.commons.dbcp2.BasicDataSource#spring-data-jpa 配置#显示 SQL 语句spring.jpa.show-sql=true#表示是否需要根据 view 的生命周期来决定 session 是否关闭spring.jpa.open-in-view=true可以修改为配置文件： application.yml， 内容为：其实 application.yml 配置文件就是将原来 application.properties 使用（.） 分割的方式， 改为树状结构， 使用（:） 分割。注意： 最后 key 的字段与值之间的冒号（:） 后面一定要有一个空格。6.2.2. application.yml 多配置文件支持1.在 application.yml 配置文件下， 增加多个 application-xxx.yml 文件名的配置文件， 其中 xxx 是一个任意的字符串。例如：application-database.ymlapplication-mvc.ymlapplication-freemarker.yml2.在 application.yml 总配置文件指定， 加载的多个配置文件例如： 要同时使用， 四个配置文件application.ymlapplication-database.ymlapplication-mvc.ymlapplication-freemarker.yml那么在 application.yml 其他配置文件指定为：6.3. 配置示例-Spring 数据源配置配置 Spring 数据源,并支持 DBCP2 数据源1.在 pom.xml 加入支持数据源的类库<!-- 数据库驱动 --><dependency><groupId>mysql</groupId><artifactId>mysql-connector-java</artifactId></dependency><!-- dbcp2 连接池 --><dependency><groupId>org.apache.commons</groupId><artifactId>commons-dbcp2</artifactId></dependency><!-- Springboot 测试包 --><dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-test</artifactId></dependency>2.找到数据源的配置类3.数据源的配置类的属性如下1.spring.datasource 这个前缀就是 DataSourceProperties 的@ConfigurationProperties(prefix ="spring.datasource")注解声明的前缀2.属性就是 DataSourceProperties 对应的属性4.测试代码package cn.itheima.test;import java.sql.SQLException;import javax.sql.DataSource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)//SpringBoot 测试要加上这个注解@SpringBootTestpublic class DataSourceTest {@Autowiredprivate DataSource dataSource;@Testpublic void dataSource() {try {System.out.println(dataSource.getConnection());} catch (SQLException e) {// TODO Auto-generated catch blocke.printStackTrace();}}} 6.4. 获得自定义 application.properties 声明的属性值使用@ConfigurationProperties 注解可以直接获得 application.properties 配置的属性值。@ConfigurationProperties 属性说明：prefix 属性： 表示获得 application.properties 时忽略的指定的前缀， 如：@ConfigurationProperties(prefix  =  "spring.resources" ,  ignoreUnknownFields  =  false )ignoreUnknownFields 属性： 忽略未知的字段值。 如果为 true 时， 就是当 application.properties 设置的输入找不到对应的字段时， 就忽略它。@ConfigurationProperties 的使用：1.在 pom.xml 导入支持的依赖包<dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-configuration-processor</artifactId><optional>true</optional></dependency>2.自定义一个 TestProperties 属性类@ConfigurationProperties(prefix = "com.ngari")public class TestProperties {private String path;public String getPath() {return path;}public void setPath(String path) {this.path = path;}}3.自定义一个 application-test.properties 文件com.ngari.path=demo-034.在 application.properties 指定 application-test.properties 配置文件spring.profiles.active=test5.启动支持 TestProperties 类自动配置在入口类 Application 增加 EnableConfigurationProperties 注解支持@SpringBootApplication@EnableConfigurationProperties(value= TestProperties.class)public class Application {public static void main(String[] args) throws Exception {//启动 Spring Boot 程序SpringApplication.run(Application.class, args);}}6.调用配置的属性 path@Controllerpublic class TestPropertiesController {@Autowiredprivate TestProperties testProperties;@RequestMapping(value="/path")@ResponseBodypublic String getPath(){System.out.println(testProperties.getPath()+"================");return testProperties.getPath();}}7.测试结果7. Spring Boot 视图7.1. 概述由于 SpringBoot 建议使用 jar 的方式发布 web 程序。 所以不建议使用 jsp 视图， 也不对 jsp 视图做默认的支持。如果确实要使用 JSP 视图来说发布 Spring Boot 的应用， 那么建议使用 war 的方式发布。Spring Boot 默认自动配置支持视图是以下的模板引擎：FreeMarkerThymeleafGroovyMustache7.2. FreeMarker 模板引擎的配置7.2.1. 配置流程1.在 pom.xml 导入 FreeMarker 模板引擎依赖的包<!-- freemarker 支持包 --><dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-freemarker</artifactId></dependency>2.Spring Boot 的模板引擎的默认路径是 resources/templates， 所以在 resources 下创建一个templates 文件夹。 将视图页面放在里面3.这样 Spring Boot 直接就支持了返回 freemarker 的 ftl 视图了。@RequestMapping(value="/index")public String index(Model model,HttpSession session){System.out.println("-测试插入数据-");Map<String, Object> entity=new HashMap<String, Object>();//插入数据entity.put("sname", "test3");studentService.insert(entity);//返回 index 就会跳到 index.ftlreturn "index";}4.根据需要可以在 resources 的 application.properties 配置文件，修改 freemarker 视图的默认属性。例如：1.application.properties 配置文件增加以下配置#setting freemarker encodingspring.freemarker.charset=UTF-87.2.2. 注意事项注意 Freemarker 的自动配置的属性类为： spring-boot-autoconfigure-1.5.4.RELEASE.jar 包的org.springframework.boot.autoconfigure.freemarker.FreeMarkerProperties 类。freemarker 视图的默认属性配置在里面如下：package org.springframework.boot.autoconfigure.freemarker;import java.util.HashMap;import java.util.Map;importorg.springframework.boot.autoconfigure.template.AbstractTemplateViewResolverProperties;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = "spring.freemarker")public class FreeMarkerProperties extends AbstractTemplateViewResolverProperties {//默认的视图的存放路径public static final String DEFAULT_TEMPLATE_LOADER_PATH = "classpath:/templates/";//默认的前缀public static final String DEFAULT_PREFIX = "";//默认的后缀public static final String DEFAULT_SUFFIX = ".ftl";private Map<String, String> settings = new HashMap<String, String>();36private String[] templateLoaderPath = new String[] { DEFAULT_TEMPLATE_LOADER_PATH };private boolean preferFileSystemAccess = true;public FreeMarkerProperties() {super(DEFAULT_PREFIX, DEFAULT_SUFFIX);} public Map<String, String> getSettings() {return this.settings;} public void setSettings(Map<String, String> settings) {this.settings = settings;} public String[] getTemplateLoaderPath() {return this.templateLoaderPath;} public boolean isPreferFileSystemAccess() {return this.preferFileSystemAccess;} public void setPreferFileSystemAccess(boolean preferFileSystemAccess) {this.preferFileSystemAccess = preferFileSystemAccess;} public void setTemplateLoaderPath(String... templateLoaderPaths) {this.templateLoaderPath = templateLoaderPaths;}} 2.查看 Spring Boot 内置的 FreeMarkerProperties 类的属性， 发现 application.properties 里面可以设置的属性竟然比 FreeMarkerProperties 定义的属性多， 为什么呢？答： 因为 Spring Boot 直接引用了 FreeMarker 框架原来内部定义的属性， 只是在前面加一个前缀。所以导致有一些没有默认值的属性不在 FreeMarkerProperties 类里面。377.3. Thymeleaf 模板引擎的配置7.3.1. 配置流程1.导入 Thymeleaf 的支持包<!-- thymeleaf 支持包 --><dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-thymeleaf</artifactId></dependency>2.Spring Boot 的 Thymeleaf 模板引擎的默认路径是 resources/templates， 所以在 resources 下创建一个 templates 文件夹。 将视图页面放在里面内容为：<!DOCTYPE HTML><!-- 注意 Thymeleaf 模板引擎一定要引入 xmlns:th="http://www.thymeleaf.org"命名空间 --><html xmlns:th="http://www.thymeleaf.org"><head><title>hello</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /></head><body><!-- ${name}用于获得 Controller 返回的 Request 的取值范围的值， ${}一定要在 th:开头的标签里才有效--><p th:text="'Hello！ , ' + ${name} + '!'" >3333</p></body></html>3.这样 Spring Boot 直接就支持了返回 Thymeleaf 的 html 视图了。@RequestMapping(value="/index")public String index(Model model){System.out.println("-测试数据-");model.addAttribute("name", "张三");38return "index";}4.根据需要可以在 resources 的 application.properties 配置文件， 增加 Thymeleaf 视图的默认属性。spring.thymeleaf.mode=HTML5spring.thymeleaf.encoding=UTF-8spring.thymeleaf.content-type=text/html#开发时关闭缓存,不然没法看到实时页面spring.thymeleaf.cache=false7.3.2. 注意事项具体的 application-thymeleaf.properties 配置文件能够配置的属性， 根据自身实际的情况， 可以查看 spring-boot-autoconfigure-1.5.4.RELEASE.jar 设置。Thymeleaf 的属性类为： org.springframework.boot.autoconfigure.thymeleaf.ThymeleafProperties7.4. JSP 视图配置（极不推荐）Spring Boot 在默认自动配置已经不支持 JSP 视图。 如果非要使用 JSP 视图。 需要我们手工配置。7.4.1. 配置流程397.4.2. 注意事项1.因为 JSP 是 JavaWEB 技术， 依赖 Servlet-API。 所以如果使用 jsp 视图发布包格式为 war 包2.也是因为 JSP 是依赖 Servlet-API 的， 所以一定要实现一个 SpringBootServletInitializer 类的子类作为项目的入口， 功能类似于 web 项目的 web.xml7.5. 默认读取的静态资源路径Spring Boot 默认读取 CSS、 JavaScript、 html、 图片等静态资源的根目录为：classpath:/META-INF/resources/classpath:/resourcesclasspath:/static/classpath:/public/也就是说 html 使用到的 CSS、 image 等静态资源可以放到以上目录文件夹例如：注意： 具体查看 org.springframework.boot.autoconfigure.web.ResourceProperties 类的配置， 如果要修改,在 appplication.properties 修改默认的路径。8. SpringBoot 整合8.1. 使用的数据库 SQL框架整合统一使用一下 SQL。-- 导出 表 school.student 结构DROP TABLE IF EXISTS `student`;CREATE TABLE IF NOT EXISTS `student` (`SID` int(11) NOT NULL AUTO_INCREMENT COMMENT '编号',`SNAME` varchar(50) DEFAULT NULL COMMENT '姓名',`SEX` char(3) DEFAULT NULL COMMENT '性别',`BIRTHDAY` date DEFAULT NULL COMMENT '生日',`AGE` int(11) DEFAULT NULL COMMENT '年龄',PRIMARY KEY (`SID`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COMMENT='学生表';-- 正在导出表 school.student 的数据： ~5 rows (大约)DELETE FROM `student`;/*!40000 ALTER TABLE `student` DISABLE KEYS */;INSERT INTO `student` (`SID`, `SNAME`, `SEX`, `BIRTHDAY`, `AGE`) VALUES(1, '张三', '男', '1990-03-05', 27),(2, '李四', '男', '1993-10-13', 24),(3, '王五', '女', '1998-02-01', 19),(4, '赵六', '男', '2000-04-02', 17),(5, '陈七', '女', '1985-01-16', 32);8.2. SpringBoot 整合 Mybatis8.2.1. 整合说明Spring Boot 默认没有对 mybatis 支持， 而是 Mybatis 对 springboot 进行了支持。 所以 Spring Boot整合 Mybatis 的整合包要去 Mybatis 的的官方寻找。路径为： https://github.com/mybatis/spring-boot-starterMaven 路径在： http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/8.2.2. 配置流程1.创建一个 Maven 项目2.在 pom.xml 导入需要的依赖包<project xmlns="http://maven.apache.org/POM/4.0.0"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"><modelVersion>4.0.0</modelVersion><groupId>cn.itheima</groupId><artifactId>spring-boot-demo-01</artifactId><version>1.0</version><parent><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-parent</artifactId><version>1.5.4.RELEASE</version></parent><dependencies><!-- freemarker 支持包 --><dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-freemarker</artifactId></dependency><!-- SpringBoot 基础包 --><dependency><groupId>org.mybatis.spring.boot</groupId><artifactId>mybatis-spring-boot-starter</artifactId><version>1.3.0</version></dependency><!-- 数据库驱动 --><dependency><groupId>mysql</groupId><artifactId>mysql-connector-java</artifactId></dependency><!-- dbcp2 连接池 --><dependency><groupId>org.apache.commons</groupId><artifactId>commons-dbcp2</artifactId></dependency><!-- Springboot 测试包 --><dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-test</artifactId></dependency></dependencies></project>3.创建包结果,并且创建三个类4.编写 Application.Java 类的内容@SpringBootApplication@EnableConfigurationProperties(value= TestProperties.class)public class Application {public static void main(String[] args) throws Exception {//启动 Spring Boot 程序SpringApplication.run(Application.class, args);}}5.编写配置文件 application.propertiesspring.datasource.url=jdbc:mysql://localhost:3306/springbootspring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.username=rootspring.datasource.password=root#dbcp2 datasourcespring.datasource.type=org.apache.commons.dbcp2.BasicDataSource6.测试数据源package com.ngari.utils;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.sql.DataSource;import java.sql.SQLException;/*** @ClassName DataSourceTest* @Description* @Author maoLy* @Date 2020/12/8**/@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTestpublic class DataSourceTest {@Autowiredprivate DataSource dataSource;@Testpublic void dataSource() {try {System.out.println("数据库连接地址"+dataSource.getConnection());} catch (SQLException e) {// TODO Auto-generated catch blocke.printStackTrace();}}}7.测试数据源正确后,编写 StudentMapper.Java 接口@Mapperpublic interface StudentMapper {@Insert(value="INSERT INTO student (SNAME, SEX, BIRTHDAY, AGE) VALUES (#{sname}, #{sex},#{birthday}, #{age})")public int insert(Map<String,Object> entity);}8.编写一个 Service 类@Servicepublic class StudentService {@Autowired(required = false)private StudentMapper studentMapper;public int insert(Map<String,Object> entity){return studentMapper.insert(entity);}}9.编写一个 Controller 类@Controllerpublic class StudentController {@Autowiredprivate StudentService studentService;@RequestMapping(value="/index")@ResponseBodypublic String index(Model model, HttpSession session){System.out.println("-测试插入数据-");Map<String, Object> entity=new HashMap<String, Object>();//插入数据entity.put("sname", "test111");studentService.insert(entity);return "这只是一句话";}}10.启动程序测试启动成功： 提示使用 8080 端口访问。11.在浏览器执行访问12.查看数据库结果,成功!8.3. Spring Boot 整合 Spring-Data-JPA8.3.1. 配置步骤1.创建一个 maven 项目2.复制依赖的包到 pom.xml 文件<project xmlns="http://maven.apache.org/POM/4.0.0"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"><modelVersion>4.0.0</modelVersion><groupId>cn.itheima</groupId><artifactId>spring-boot-demo-05-data-jpa</artifactId><version>1.0</version><parent><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-parent</artifactId><version>1.5.4.RELEASE</version></parent><dependencies><dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-web</artifactId></dependency><!-- 增加 springboot 整合 data-jpa 的包 --><dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-data-jpa</artifactId></dependency><!-- 数据库驱动 --><dependency><groupId>mysql</groupId><artifactId>mysql-connector-java</artifactId></dependency><!-- dbcp2 连接池 --><dependency><groupId>org.apache.commons</groupId><artifactId>commons-dbcp2</artifactId></dependency><!-- SpringBoot 测试包 --><dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-test</artifactId></dependency></dependencies></project>3.创建一个入口类， 用于启动 SpringBootpackage cn.itheima;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application {public static void main(String[] args) {SpringApplication.run(Application.class, args);}} 4.编写 application.properties.注意文件名不要写错， 配置数据源#配置数据源spring.datasource.url=jdbc:mysql://localhost:3306/schoolspring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.username=rootspring.datasource.password=123456spring.datasource.type=org.apache.commons.dbcp2.BasicDataSource#spring-data-jpa 配置#显示 SQL 语句spring.jpa.show-sql=true#表示是否需要根据 view 的生命周期来决定 session 是否关闭spring.jpa.open-in-view=true5.编写一个测试类测试数据源是否连接数据库成功49package cn.itheima.test;import java.sql.SQLException;import javax.sql.DataSource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTestpublic class DataSourceTest {@Autowiredprivate DataSource dataSource;@Testpublic void dataSource(){try {System.out.println(dataSource.getConnection());} catch (SQLException e) {// TODO Auto-generated catch blocke.printStackTrace();}}} 如果出现以下信息表示测试成功6.创建一个实体类package cn.itheima.pojo;import java.io.Serializable;import java.util.Date;50import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;@Entity@Table(name="student")public class Student implements Serializable{@Id@GeneratedValue(strategy=GenerationType.IDENTITY)private Long sid;//BIGINT(20) NOT NULL AUTO_INCREMENT,private String sname;//VARCHAR(255) NULL DEFAULT NULL,private String sex;//VARCHAR(255) NULL DEFAULT NULL,private Integer age;//INT(11) NULL DEFAULT NULL,private Date birthday;//DATETIME(6) NULL DEFAULT NULL,public Long getSid() {return sid;} public void setSid(Long sid) {this.sid = sid;} public String getSname() {return sname;} public void setSname(String sname) {this.sname = sname;} public String getSex() {return sex;} public void setSex(String sex) {this.sex = sex;} public Integer getAge() {return age;} public void setAge(Integer age) {this.age = age;} public Date getBirthday() {return birthday;51} public void setBirthday(Date birthday) {this.birthday = birthday;}} 7.创建一个操接口package cn.itheima.repository;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.stereotype.Repository;import cn.itheima.pojo.Student;@Repositorypublic interface StudentRepository extends JpaRepository<Student, Long> {} 8.创建一个 Servicepackage cn.itheima.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import cn.itheima.pojo.Student;import cn.itheima.repository.StudentRepository;@Servicepublic class StudentService {@Autowiredprivate StudentRepository studentRepository;@Transactionalpublic void save(Student entity){studentRepository.save(entity);}}529.创建一个 Controllerpackage cn.itheima.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import cn.itheima.pojo.Student;import cn.itheima.service.StudentService;@RestControllerpublic class StudentController {@Autowiredprivate StudentService studentService;@RequestMapping(value="/")public String save(){Student entity=new Student();entity.setSname("jpa 用户");studentService.save(entity);return entity.getSid().toString();}} 10.启动项目53启动成功信息， 提示使用 8080 端口访问成功信息后台输出的语句548.3.2. 注意事项1.Spring-data-jpa 只要 Maven 导入 spring-boot-starter-data-jpa 模块已经数据库的驱动包。 只要配置好 Spring 数据源就可以直接使用。 如果需要连接池， 可以再加一个连接池<!-- 增加 springboot 整合 data-jpa 的包 --><dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-data-jpa</artifactId></dependency><!-- 数据库驱动 --><dependency><groupId>mysql</groupId><artifactId>mysql-connector-java</artifactId></dependency>2.查看 spring-boot-autoconfigure-1.5.4.RELEASE.jar 可以获得整合的信息。（1） .可以配置的参数查看 org.springframework.boot.autoconfigure.orm.jpa.JpaProperties 类（2） .需要了解整合的代码查看org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration559. 打包部署SpringBoot 支持使用 Jar 内嵌 Web 服务器（Tomcat） 的方式发布， 也支持生成 war 包放在外置的web 服务器运行。9.1. 使用 jar 发布应用9.1.1. 配置步骤1.pom.xml 要显示加入插件 org.springframework.boot， 否则无法产生清单<build><plugins><!-- 如果不配置全信息， 打出来的包没有清单文件 --><plugin><groupId>org.springframework.boot</groupId><artifactId>spring-boot-maven-plugin</artifactId></plugin></plugins></build>2.使用里面 package 打包563.打包成功， 产生 spring-boot-demo-01-1.0.jar 文件4.将 spring-boot-demo-01-1.0.jar 复制到一个文件夹下， 在同一级目录编写一个 bat文件。内容格式： #java -jar <jar 名>， 如下：java -jar spring-boot-demo-01-1.0.jar575.双击 bat 文件 startup.bat9.1.2. 修改内嵌 Tomcat 的参数在 application.properties 设置相关参数即可， 如：#设置 Tomcat 端口server.port=80#设置 Tomcat 路径编码server.tomcat.uri-encoding=UTF-8#设置超时时间server.connection-timeout=10009.2. 使用 war 发布应用9.2.1. 配置流程1.修改 pom.xml 文件去掉嵌入式的 Tomcat 服务器， 以及增加 serlvet-api 依赖包<dependency><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-web</artifactId><!-- 移除嵌入式 tomcat 服务器 --><exclusions><exclusion><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-tomcat</artifactId>58</exclusion></exclusions></dependency><!-- 加入 servlet-api 的支持 --><dependency><groupId>javax.servlet</groupId><artifactId>javax.servlet-api</artifactId><version>3.1.0</version><scope>provided</scope></dependency>2.修改 pom.xml 文件的打包方式为 war3.增加一个 web 程序的入口类要和 Application 同一级目录package cn.itheima;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.support.SpringBootServletInitializer;/*** 如果项目需要使用 war 发布， 需要创建这个类， 作为 web 程序的入口* @author ranger* */public class ServletInitializer extends SpringBootServletInitializer {59@Overrideprotected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {//表示获得 web 的请求时， 调用 Application 类的实现return builder.sources(Application.class);}} 4.打包生成 war 文件5.复制 spring-boot-demo-01-1.0.war 放在 Tomcat 的 webapps 下6.启动 Tomcat， Tomcat 控制台提示 SpringBoot 信息607.浏览器访问， 成功http://localhost:8080/spring-boot-demo-01-1.0/index9.2.2. 注意事项web 网站入口类一定要继承 SpringBootServletInitializer 类， 而且必须要给 SpringBoot 入口类Application 同一级目录。
